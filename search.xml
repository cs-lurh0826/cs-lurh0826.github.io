<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端面试 —— React篇]]></title>
    <url>%2FInterview-Questions%2Ffrontend-interview-react%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在准备前端面试的过程中，发现前端的知识体系涉及的内容很广很多，在网上搜罗整理了一些前端面试的问题及答案，一方面是为了面试，另一方面是对很多基础和常用知识的复习。本篇是React篇&emsp;&emsp;传送门：&emsp;&emsp;前端面试 —— JavaScript基础篇 问题汇总React生命周期函数？&emsp;&emsp;生命周期函数指在某一个时刻组件会自动调用执行的函数&emsp;&emsp;componentWillMount() -&gt; 组件即将被挂载(第一次)到页面的时刻自动执行&emsp;&emsp;render() -&gt; state/props改变时会自动调用，渲染页面&emsp;&emsp;componentDidMount() -&gt; 组件被挂载(第一次)到页面之后自动执行&emsp;&emsp;componentWillReceiveProps()[props] -&gt; 1. 一个组件从父组件接收了参数；2. 如果这个组件第一次存在于父组件中，不会执行；如果这个组件之前已经存在于父组件中，才会执行&emsp;&emsp;shouldComponentUpdate() -&gt; 组件更新之前自动执行，返回布尔值决定组件是否更新&emsp;&emsp;componentWillUpdate() -&gt; 组建更新之前，shouldComponentUpdate()返回true之后，自动执行&emsp;&emsp;componentDidUpdate() -&gt; 组建更新完成之后自动执行&emsp;&emsp;componentWillUnmount() -&gt; 当组件即将被从页面中剔除的时候自动执行&emsp;&emsp;getDerivedStateFromProps() -&gt; React新的生命周期函数，父组件传递给子组件的props发生变化的时候，就会执行，然后更新state，为了替代即将被废除的componentWillReceiveProps()这个生命周期函数&emsp;&emsp;getSnapshotBeforeUpdate() -&gt; React新的生命周期函数，当组件发生更新之前，组件会获取到DOM上的信息，传递给componentDidUpdate()作为最后一个参数。如果在组件更新时，想获取到更新前的页面DOM结构时候，可以使用&emsp;&emsp;1. Initialization(初始化): setup state and props (constructor())&emsp;&emsp;2. Mounting(挂载): componentWillMount() -&gt; render() -&gt; componentDidMount()&emsp;&emsp;3. Updation(更新: state/props改变):&emsp;&emsp;&emsp;componentWillReceiveProps()[props] -&gt; shouldComponentUpdate() -&gt;&emsp;&emsp;&emsp;| true: componentWillUpdate() -&gt; render() -&gt; componentDidUpdate()&emsp;&emsp;&emsp;| false: x&emsp;&emsp;4. Unmounting(组件去除): componentWillUnmount() redux中间件（thunk、saga、…）的原理是什么？&emsp;&emsp;redux流程是派发action，action传给store，store转给reducer，reducer再修改store中间件位于派发action和action到store之间，也就是action和store之间。action和store之间沟通的桥梁是dispatcher，如果单纯调用store.dispatch(action)，直接将action传递给store，此时action只能是一个对象；而redux-thunk的引入使得这个action可以是一个函数。&emsp;&emsp;具体原理：action到达store之前，会经过中间件，中间件会将函数式action转换成一个对象再传递给store。根据源码，我们可以看出如果传入的action是函数，则返回这个函数的调用，如果本身传入的函数是异步函数，我们完全可以在函数调用结束后，获取数据再次触发dispatch实现异步效果。 你会把数据统一放到redux中管理，还是共享数据放在redux中管理？&emsp;&emsp;1. 共享数据放在redux中管理，有一个明显的缺点，就是对于业务复杂的项目来说，可维护性差：因为对于一个组件来说，有可能既有state存储数据，又有props存储数据，还有redux存储数据，一旦出现问题，很难进行定位；所有数据统一redux管理，数据管理方式是相同的，问题定位方便&emsp;&emsp;2. 项目的可扩展性，可能某一组件的state数据在未来成为了共享数据，此时再进行数据的迁徙，不如最开始直接统一管理&emsp;&emsp;3. 附加：immutable + react-redux 可以提高项目性能 componentWillReceiveProps()的调用时机？&emsp;&emsp;1. 子组件从父组件接收了参数&emsp;&emsp;2. 如果子组件第一次存在于父组件中，不会执行；如果子组件之前已经存在于父组件中，才会执行 React性能优化的实践例子？&emsp;&emsp;PureComponent - 已经实现了shouldComponentUpdate()这个生命周期函数 [+ immutable.js 库] 虚拟DOM是什么？为什么虚拟DOM会提升代码性能？&emsp;&emsp;真实DOM节点的一个JS对象；不采用虚拟DOM时，如果想要比较页面差异，需要进行真实DOM节点比较，而DOM节点会绑定事件、有属性、各种方法，做比较耗性能；而单纯比较JS对象比较快，所以虚拟DOM的出现提升了react性能。 webpack中，是借助loader完成的JSX代码的转化，还是babel？&emsp;&emsp;babel-preset-react完成react代码转化成ES5，Vue是借助于webpack的vue-loader 调用setState后，发生了什么？&emsp;&emsp;setState是一个异步过程，它会集齐一批需要更新的组件然后一起更新 setState是异步的，这个点你什么时候遇到过坑？&emsp;&emsp;推荐使用函数式调用，例：1234this.setState((prevState) =&gt; (&#123; age: prevState.age + 1 &#125;), () =&gt; &#123;&#125;); // 在第二个回调函数中可以得到更新的age值 &emsp;&emsp;1. setState异步的，是会将短时间内的所有setState合并然后进行改变，如果用对象式调用，可能会出现阶跃式变化。&emsp;&emsp;2. 因为是异步，所以在第二个回调函数中可以保证得到已经更新的值 refs的作用是什么？你在什么业务场景下使用过refs？&emsp;&emsp;操作DOM -&gt; 渲染了一个图片，展示完图片后，获取宽高（放大镜🔍功能） ref采用函数式写法的好处？&emsp;&emsp;获取DOM元素，切记ref使用函数式写法，例：1234render() &#123; return &lt;div ref=&#123;(div) =&gt; &#123; this.elem = div &#125;&#125;&gt;&lt;/div&gt; // elem名字任意，现在我们可以通过this.elem访问该div标签&#125; &emsp;&emsp;函数式写法好处在，方便react销毁组件/重新渲染时，有效清空ref引用里的内容，防止内存泄漏 高阶组件你是怎么理解的，它本质是一个什么东西？&emsp;&emsp;设计模式中有一个说法：组合优于继承。&emsp;&emsp;高阶组件（函数）接收参数，返回函数；高阶组件是对组件进行包装，然后返回一个新的组件。通常情况下，当一个组件会被很多组件调用，但是其中有些部分需要动态改变，我们就可以把公用的部分写入高阶组件，然后通过向高阶组件传递额外参数来进行动态改变。&emsp;&emsp;Hooks的出现解决了高阶组件地狱的问题。 受控组件和非受控组件的区别？&emsp;&emsp;受控组件的改变完全受控于数据的变化；非受控组件通过refs获取DOM节点上的内容进行操作。&emsp;&emsp;受控组件更好：react是一个数据驱动的框架，是一个反馈与相应式的框架。 函数组件和Hooks？&emsp;&emsp;Hooks的引入使得函数组件可以使用state，常见的一些API有useState(), useEffect(), useMemo(), useCallback(), useContext(), … 函数组件怎么做性能优化？&emsp;&emsp;函数组件相比类组件好在：由于是函数，没有生命周期，没有构造类的过程；但是，只要props改变，就会导致函数组件重新渲染。因此，可以使用React中的memo()对函数组件进行包装，包装后的组件就带有了shouldComponentUpdate()的特性，因此可以提升性能。 哪个生命周期里发送ajax请求？&emsp;&emsp;推荐在componentDidMount()&emsp;&emsp;为什么不推荐componentWillMount()？&emsp;&emsp;1. componentWillMount()在新版本react中已经被废弃了&emsp;&emsp;2. 做SSR（服务器端渲染）时，componentWillMount()要做服务器端数据的获取，不能被占用 SSR的原理是什么？&emsp;&emsp;因为虚拟DOM的引入，我们可以在服务器端对DOM的JS对象进行操作渲染，运行react的代码 React, jquery, vue是否可以共存在一个项目中？&emsp;&emsp;是可以共存的，怎么共存？例：1234567... &lt;body&gt; &lt;div&gt;&lt;div&gt; &lt;div id=‘react’&gt;&lt;/div&gt; &lt;div id=‘vue’&gt;&lt;/div&gt; &lt;/body&gt;... &emsp;&emsp;jquery接管第一个div，只操作第一个div下的DOM&emsp;&emsp;react接管第二个div，只操作第二个div下的DOM&emsp;&emsp;vue接管第三个div，只操作第三个div下的DOM 如何避免ajax数据重新获取？&emsp;&emsp;可以在react-redux中进行状态管理，比如可以用一个共享数据getData来表示是否已经获取过数据，true即获取过，则不需要再次请求获取数据；反之进行ajax请求获取数据。 react-router4的核心思想是什么？和3有什么区别？&emsp;&emsp;4 - 路由成为了组件，使用灵活，例如：, ，组件式路由思想&emsp;&emsp;3 - 基于配置的路由思想 react-router的基本原理, hashHistory和browserHistory?&emsp;&emsp;hashHistory - 路由不需要后端支持，上线可以直接使用&emsp;&emsp;browserHistory - URL形式漂亮，用户体验好，但是必须在后端Apache/Nginx服务器做相应路由配置 组件是什么？类是什么？类被编译成什么？&emsp;&emsp;模块的概念，存在于webpack一类的打包工具里，组件不是模块！！！组件指的是页面的一部分，本质上就是一个类，类是带有数据和功能的集合，ES6的类对应（编译后）ES5的构造函数。 reselect是做什么使用的？&emsp;&emsp;如果依赖的数据没有发生变化，计算属性就不会重新计算（做了缓存，提升代码性能） 什么情况下使用异步组件（reloadable库）？&emsp;&emsp;进入首页，只引入首页的代码，单独首页的包；同理，详情页面、后台每个页单独一个包。访问哪个页面，再加载这个页面对应的JS文件，这样可以把一个容量大的项目拆分成数个小包（异步组件） xss攻击在react中如何防范？&emsp;&emsp;首先react本身已经做好了xss攻击防护，但是有：1dangerouslySetInnerHTML=&#123;&#123;__html: ‘&lt;script&gt;alert(1)&lt;/script&gt;’&#125;&#125; &emsp;&emsp;此时就容易被攻击，所以要慎用dangerouslySetInnerHTML 你是如何跟着社区成长的？&emsp;&emsp;根据自身成长经历开放性回答 文章引用和推荐 必须要会的50个React面试题 来自前端先锋的掘金]]></content>
      <categories>
        <category>Interview Questions</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试 —— JavaScript基础篇]]></title>
    <url>%2FInterview-Questions%2Ffrontend-interview-js%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在准备前端面试的过程中，发现前端的知识体系涉及的内容很广很多，在网上搜罗整理了一些前端面试的问题及答案，一方面是为了面试，另一方面是对很多基础和常用知识的复习。本篇是JavaScript基础篇&emsp;&emsp;传送门：&emsp;&emsp;前端面试 —— React篇 问题汇总JS中基本数据类型和引用类型有哪些？&emsp;&emsp;JS中基本类型（值类型）有Number、Boolean、String、Undefined、Null、Symbol（ES6）；引用类型有Object、Array、Function、Date、RegExp… JS中基本数据类型和引用类型在内存上的区别？&emsp;&emsp;基本数据类型是存储在栈内存中的简单数据段，其变量和数据以及存储空间是一一对应的；而引用类型是存储在堆内存中的对象，通常来说可以多个引用类型变量指向同一存储空间块 null和undefined的区别？&emsp;&emsp;null表示的是一个空指针，也就是“无”的对象，转为数值是0；而undefined表示的是“无”的原始值，转为数值是NaN。当声明的变量还未被初始化时，默认值时undefined，而null通常来说是空的对象 如何判断一个对象是否为空对象？&emsp;&emsp;a. 利用for…in遍历对象属性，如果for…in执行，则非空对象；否则空对象&emsp;&emsp;b. 利用JSON.stringify()将检测对象转换成JSON字符串，如：JSON.stringify(target) === ‘{}’&emsp;&emsp;c. 利用ES6新增的Object.keys()方法，如果目标是空对象，该方法会返回一个空数组 原型规则和原型链？&emsp;&emsp;a. 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了”null”以外）&emsp;&emsp;b. 所有的引用类型（数组、对象、函数），都有一个__proto__（隐式原型）属性，属性值是一个普通的对象&emsp;&emsp;c. 所有的函数都有一个prototype（显式原型）属性，属性值是一个普通的对象&emsp;&emsp;d. 所有的引用类型（数组、对象、函数），__proto__属性指向（===）它的构造函数的prototype属性&emsp;&emsp;e. 当试图得到一个对象（引用类型）的某个属性或方法时，如果这个对象本身没有，那么会去proto（对应构造函数的prototype）中去寻找；如果依然不存在，则会去构造函数上一层的prototype继续查找，直到找到目标属性/方法，或者到该条链路径的顶点，这条查找的链路径就是原型链 typeof、instanceof和valueOf区别？&emsp;&emsp;typeof操作符返回字符串，表示未经求值的操作数的类型，返回值为number、boolean、string、undefined、object、function、symbol（ES6）&emsp;&emsp;A instanceof B用来判断A是否是构造函数B的一个实例或者其子类的一个实例对象&emsp;&emsp;valueOf其实就是返回对象的原始值 instanceof的原理？&emsp;&emsp;判断某个构造函数的显式原型（prototype）属性所指向的对象是否存在于要检测对象的原型链上 new操作符的原理？&emsp;&emsp;a. 生成一个新的对象，并将this指向这个对象&emsp;&emsp;b. 执行构造函数代码，并根据传入参数对this的相应属性进行赋值&emsp;&emsp;c. 默认将this对象返回（因此无需显式调用return语句），并赋值给对应的实例变量 原型链的封装和继承？&emsp;&emsp;原型链的封装和继承其实就是将实例具有共同属性和方法绑定在其构造函数的prototype上，这样可以有效地避免在生成实例时，重复开辟很多相同属性的内存空间，转而用原型链继承的方式传递给实例的proto属性，因此实例可以使用这些属性和方法 正则表达式？&emsp;&emsp;考察正则一般会根据要求写出相应表达式 - 练习传送门 阻止冒泡的方法？阻止默认事件的方法？&emsp;&emsp;阻止冒泡：考虑浏览器的兼容性问题，通常是将event.stopPropagation()和event.cancelBubble = true组合使用。&emsp;&emsp;阻止默认事件：同样地，event.preventDefault()和event.returnValue = false; JS的垃圾回收机制（GC）？&emsp;&emsp;最常用的方法是“引用计数”：语言引擎有一张“引用表”，保存了内存中所有资源（通常是各种值）的引用次数。当一个值的引用次数为0，表示这个值不再使用了，然后可以将这块内存释放。也有特殊情况存在，就是值不再需要了，但是引用数却不是0，因此GC无法释放这块内存，导致内存泄漏&emsp;&emsp;第二种是标记清除，当变量进入执行环境标记为“进入环境”，当变量离开执行环境时标记为“离开环境”，标记为“进入环境”的是不能被回收的，而“离开环境”可以被回收&emsp;&emsp;详细请见https://juejin.im/post/5b684f30f265da0f9f4e87cf 如何判断一个变量是Array类型？&emsp;&emsp;首先，typeof操作符是不能区分对象（object）和数组（array）的，都会返回”object”，因此可用以下三种方法来判断Array类型：&emsp;&emsp;a. Array.isArray(arr)&emsp;&emsp;b. arr instanceof Array&emsp;&emsp;c. Object.prototype.toString.call(arr) === ‘[object Array]’ 谈一谈闭包？&emsp;&emsp;闭包就是能够读取其他函数内部变量的函数，在JS中，只有函数内部的子函数才能读取其内部变量，因此闭包简单说也可以是定义在函数内部的函数。本质上，闭包是将函数内部和外部连接起来的桥梁；当某个函数的内部子函数访问该函数的内部变量时，这个子函数就构成了闭包。闭包可以用来封装变量，收敛权限。123456789function getList() &#123; var _list = [1, 2, 3, 4]; return function(index) &#123; console.log(_list[index]); &#125;&#125;var getElem = getList();getElem(1); &emsp;&emsp;闭包的三个特性：1. 函数嵌套函数；2. 内部函数使用外部函数的参数和变量；3. 外部的参数和变量不会被GC回收&emsp;&emsp;闭包的缺点：1. 常驻内存，增加了内存使用量；2. 使用不当造成内存泄漏 call、apply、bind区别？&emsp;&emsp;call和apply都是将函数的this对象绑定到传入的第一个参数对象上，而bind是返回一个新函数，然后将this设置为第一个参数，并接受额外参数；call和apply的区别是参数接收形式，apply是参数数组，call是参数列表 this的使用场景？&emsp;&emsp;this要在执行时才能确认值，定义时无法确认：a. 作为构造函数执行; b. 作为对象属性执行; c. 作为普通函数执行; d. call、apply、bind; e. 箭头函数中的this（ES6） 创建对象的多种方式？&emsp;&emsp;a. 工厂模式：定义一个函数，在函数内部创建Object对象，然后增加需要的属性（值/函数），返回这个对象。缺点：对象无法识别，因为所有实例都指向一个原型&emsp;&emsp;b. 构造函数模式：利用构造函数来创建对象。优点：实例可以为一个特定类型，缺点：耗内存，每个实例，都需要创建所有属性和方法。&emsp;&emsp;c. 原型模式：利用原型链，在构造函数的prototype上加入需要的方法和属性。优点：节省内存，不用反复创建方法，缺点：所有属性和方法都是共享的，无法初始化参数&emsp;&emsp;d. 组合模式：结合b和c，共享的属性和方法使用原型模式，然后利用构造函数模式初始化独有参数。优点：该共享共享，该私有私有，最广泛的创建方式 实现继承的多种方式和优缺点？&emsp;&emsp;a. 原型链继承：类型的所有属性都被实例共享；2. 创建子类实例的时候，无法向父类传参。&emsp;&emsp;b. 构造函数继承（经典继承）：在子类型中调用父类型的构造函数并用call改变this指向，优点：避免了类型的属性被所有实例共享；2. 可以向父类型传递参数；缺点：耗内存，新建一个实例，就会新创建所有的方法和属性，不管是否是相同的。&emsp;&emsp;c. 组合继承：a和b混用。缺点是会调用父构造函数两次&emsp;&emsp;d. 原型式继承：模拟Object.create()的实现，将传入参数作为对象的原型。缺点：共享&emsp;&emsp;e. 寄生式继承：创建一个仅用于封装继承过程的函数，函数内部以某种形式增强对象，最后返回对象。跟b缺点一样&emsp;&emsp;f. 寄生组合式继承：将组合继承的两次父构造函数调用，减少为一次&emsp;&emsp;详细请见https://juejin.im/post/5d28374951882564ca686ef2 匿名函数的应用场景？&emsp;&emsp;a. 闭包; b. 自执行函数（匿名函数）; c. 回调函数 attribute和property的区别？&emsp;&emsp;attribute是指HTML元素上的属性，使用setAttribute()和getAttribute()来设置和获取；而property是JS对象的属性（获取的DOM节点在JS中是一个对象），设置和获取与常规JS对象属性无异 window.onload和document.DOMContentLoaded两个事件的区别？&emsp;&emsp;window.onload在页面的全部资源（包括样式表、图片、音频、子框架…）加载完后执行；而DOMContentLoaded是在HTML文档加载和解析后执行，即DOM渲染完执行，不需要等待其他资源加载&emsp;&emsp;DOM完整解析过程https://www.jianshu.com/p/1a8a7e698447 == 和 === 的区别？&emsp;&emsp;== 是弱相等，会先进行强制类型转换，然后进行值比较；=== 是严格相等，会比较两个变量的类型和值 [], [] === [], [] == []？&emsp;&emsp;空数组[]在JS中也是一个object，因此用在判断条件时会转换成true；但是任意值和布尔值比较时，都会将两边的值转换成Number: [] -&gt; 0, false -&gt; 0, true -&gt; 1&emsp;&emsp;[] == [] 和 [] === [] 都是false，因为 [] 属于引用类型，引用类型的比较是需要比较两个引用值在内存中是否指向同一对象，两个空数组互不相关，因此都是false undefined == undefined, undefined === undefined？&emsp;&emsp;undefined == undefined, undefined === undefined 都是true，因为undefined在JS是基本类型，也就是值类型，且只有一个值，所以无论是值和类型都是相等的。 JS的作用域有几种？{}是不是作用域？&emsp;&emsp;通常来说，作用域被分为全局作用域和局部作用域，全局作用域就是在代码块之外的部分，而局部作用域在ES6之前是只有函数作用域一种的，而且在函数作用域中声明变量时，必须使用var关键字，否则会因为变量提升成为全局变量。ES6，引入了let和const，拥有块级作用域（局部作用域）了，因此{}代码块是作用域(ES6)，而ES5中只有{}是函数的时候才算做作用域 DOM事件绑定的几种方式（尤其是DOM0和DOM2）？&emsp;&emsp;a. DOM元素中直接绑定；b. 在JS代码中使用属性绑定（DOM0级绑定）；c. 绑定事件监听函数（DOM2级绑定）&emsp;&emsp;DOM0级事件处理程序（属性绑定，兼容性好）：将一个函数赋值给一个事件处理程序属性。特点：简单，跨浏览器。例如：btn.onclick = function() {xxx}, btn.onclick = null&emsp;&emsp;DOM2级事件处理程序（函数绑定，兼容性不好）：使用addEventListener()和removeEventListener()来绑定和解绑事件的，可以处理多个事件处理程序，并按照顺序触发，移除事件和绑定事件传入的参数相同，绑定事件时使用匿名函数的话将无法移除&emsp;&emsp;DOM0级事件会覆盖，DOM2不会覆盖，会依次执行，DOM0级和DOM2级可以共存，不会相互覆盖 DOM事件中target和currentTarget的区别？&emsp;&emsp;事件中target是一个触发事件的对象的引用，当事件处理程序在事件的冒泡或捕获阶段被调用；而currentTarget指的是当事件遍历DOM时，标识事件的当前目标&emsp;&emsp;简言之，e.target指向触发事件监听的对象；e.currentTarget指向添加事件监听的对象。利用这两个特性，可以实现事件代理 JS的事件流模型？&emsp;&emsp;事件流描述的是从页面中接受事件的顺序&emsp;&emsp;冒泡事件流：从事件开始的具体元素，一层层向上传播直到window&emsp;&emsp;捕获事件流：捕获的顺序与冒泡刚好相反，是在事件到达目标之前捕获它，而最具体的节点是最后才接收到事件的&emsp;&emsp;DOM事件流：DOM2级规定的事件流包括三个阶段 - 事件捕获阶段、处于目标阶段、事件冒泡阶段。即使DOM2级规定在捕获阶段不会涉及事件目标，但是由于浏览器支持，所以有两个机会在目标对象上操作事件 普通函数和构造函数的区别？&emsp;&emsp;a. 构造函数使用new关键字调用，而普通函数不需要&emsp;&emsp;b. 构造函数内部可以使用this关键字，普通函数内部不建议使用this关键字，因为这时候this指向window全局对象，会无意间增加一些全局变量或函数&emsp;&emsp;c. 构造函数首字母建议大写；普通函数首字母建议小写&emsp;&emsp;d. 构造函数默认会返回this对象，不用显式return，而普通函数要想返回值需要return 给定一个元素获取其相对于视图窗口的坐标？&emsp;&emsp;获取视口坐标可以通过调用元素的getBoundingClientRect()方法，方法返回的一个有left、right、top、bottom属性的对象，分别表示元素四个位置相对于视口的坐标。该方法返回的坐标包含元素的内边距和边框，不包含外边距。 JS如何实现重载和多态？&emsp;&emsp;因为JS本身不支持重载的，所以有：a. 根据arguments个数实现重载，arguments检测传参的个数，然后在执行不同的方式；b. 检测数据类型实现重载，根据传参的数据类型，调用不同的方式，用typeof检测&emsp;&emsp;多态：利用构造函数的prototype属性，来实现多态，代码示例：12345678910111213function makeSound(animal) &#123; animal.sound();&#125;function Duck() &#123;&#125;function Chicken() &#123;&#125;Duck.prototype.sound = function() &#123;console.log(&apos;gagaga&apos;);&#125;Chicken.prototype.sound = function() &#123;console.log(&apos;gegege&apos;);&#125;var d = new Duck();var c = new Chicken();makeSound(d);makeSound(c); 内存泄漏的原因和场景？&emsp;&emsp;内存泄漏就是不再被需要的内存，由于某种原因，无法释放&emsp;&emsp;a. 全局变量造成内存泄漏&emsp;&emsp;b. 闭包造成内存泄漏&emsp;&emsp;c. 未销毁的定时器和回调函数造成内存泄漏&emsp;&emsp;d. DOM引用造成内存泄漏 JS中的事件循环￼？&emsp;&emsp;事件循环机制 = JS异步执行机制 for…in和forEach的使用场景？&emsp;&emsp;forEach循环缺点就是中途无法跳出，但是在多数情况下是遍历数组的首选&emsp;&emsp;for…in遍历数组的缺点：&emsp;&emsp;a. 数组键名通常是数字，而for…in是以字符串作为键名的，如果使用数组的index参与了运算，可能会得到预期不符的结果&emsp;&emsp;b. for…in不仅会遍历数组的键名，还会遍历其他手动添加的键，甚至原型链上的键&emsp;&emsp;c. 某些情况下，for…in循环会以任意顺序遍历键名&emsp;&emsp;总之，for…in适合遍历对象，而非数组 手指点击触控屏是什么事件？&emsp;&emsp;触摸事件：touchstart, touchmove, touchend (最常用的前三个), touchcancel 文章引用和推荐 面试中会遇到的正则题 来自呆头呆脑丶的掘金 javascript垃圾回收机制 来自李赫feixuan的掘金 JavaScript之继承的多种方式和优缺点 来自老詹啊的掘金 window.onload和DOMContentLoaded 的区别 来自初入前端的小菜鸟的简书 面试之万能答案：事件循环 来自蔓越莓的掘金 移动端手势库设计与实践 来自连城的掘金 你真的理解事件冒泡和事件捕获吗？ 来自Coderfei的掘金]]></content>
      <categories>
        <category>Interview Questions</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渐进式网络应用(Progressive Web Apps)]]></title>
    <url>%2FDeveloper-Tools%2Fpwa-basic%2F</url>
    <content type="text"><![CDATA[渐进式网络应用程序(PWA)PWA主要组成技术Service Worker - Core服务工作线程 - 独立于页面，常驻内存运行；代理网络请求；依赖HTTPS Promise“承诺”控制流 - 优化JS回调问题；async/await语法同步化；Service Worker的API风格 fetch网络请求 - 比XMLHttpRequest更简洁；Promise风格；依旧有不足 cache API支持资源的缓存系统 - 缓存资源(css/scripts/image)；依赖Service Worker代理网络请求；支持离线程序运行 Notification API消息推送 - 依赖用户授权；适合在Service Worker中推送]]></content>
      <categories>
        <category>Developer Tools</category>
      </categories>
      <tags>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集(Union Find)]]></title>
    <url>%2FData-Structure%2Funion-find%2F</url>
    <content type="text"><![CDATA[并查集的定义&emsp;&emsp;一种不一样的树形结构，其子节点指向父节点(树通常是父节点指向子节点)。&emsp;&emsp;对于一组数据，主要支持两个动作:&emsp;&emsp;union(p,q) 合并p和q两组数据及其集合&emsp;&emsp;isConnected(p,q) 查询p和q两组数据是否属于同一集合 并查集的应用: 连接问题(Connectivity Problem)&emsp;&emsp;连接问题和路径问题: 存在路径/不存在 = 连接/不连接&emsp;&emsp;但，连接问题比路径问题要回答的内容少，连接回答是否连接，而路径问题需要完整路径 经典问题之一：“网络”中节点间的连接状态经典问题之二：数学中集合类的实现(求并集)代码实现(Java)&emsp;&emsp;👇先定义接口，然后使用不同底层数据结构来实现并查集12345public interface UF &#123; int getSize(); boolean isConnected(int p, int q); // id为p，id为q的两组数据 void unionElements(int p, int q);&#125; Union Find I - Quick Find&emsp;&emsp;使用一个id数组来存储不同数据所在的集合id&emsp;&emsp;查找O(1)，合并O(n)1234567891011121314151617181920212223242526272829303132333435363738394041public class UnionFind1 implements UF &#123; private int[] id; // id数组 public UnionFind1(int size) &#123; id = new int[size]; for (int i = 0 ; i &lt; size ; i++) &#123; id[i] = i; &#125; &#125; @Override public int getSize() &#123; return id.length; &#125; // 查看元素p和q是否同属一个集合 @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; // 合并元素p和q的集合 @Override public void unionElements(int p, int q) &#123; int pID = find(p); int qID = find(q); if (pID == qID) return; for (int i = 0 ; i &lt; id.length ; i++) &#123; if (id[i] == pID) &#123; id[i] = qID; &#125; &#125; &#125; // 查找元素p所对应的集合编号 private int find(int p) &#123; if (p &lt; 0 || p &gt;= id.length) throw new IllegalArgumentException(&quot;out of bound&quot;); return id[p]; &#125;&#125; Union Find II - Quick Union&emsp;&emsp;将每一个元素，看做是一个节点，用数组实现子节点指向父节点的思想&emsp;&emsp;parent数组代表每个元素的父节点(最终形成的是个森林)&emsp;&emsp;查找O(h)，合并O(h)，h是对应元素所在树的深度，通常比数据总量n要小，但没有具体的log关系，因为树的分支是不确定的12345678910111213141516171819202122232425262728293031323334353637383940public class UnionFind2 implements UF &#123; private int[] parent; // parent数组 public UnionFind1(int size) &#123; parent = new int[size]; for (int i = 0 ; i &lt; size ; i++) &#123; parent[i] = i; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; // 查看元素p和q是否同属一个集合 @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; // 合并元素p和q的集合，O(h) @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; parent[pRoot] = qRoot; &#125; // 查找元素p所对应的集合编号，O(h) private int find(int p) &#123; if (p &lt; 0 || p &gt;= id.length) throw new IllegalArgumentException(&quot;out of bound&quot;); while (p != parent[p]) &#123; p = parent[p]; &#125; return p; &#125;&#125; Union Find III - 基于size的优化&emsp;&emsp;在UnionFindII中，合并元素时可能会导致树退化成链表，性能无法保证&emsp;&emsp;因此，为了防止此类情况，合并时采取将节点数量少的树的根节点指向节点数量多的树的根节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class UnionFind3 implements UF &#123; private int[] parent; // parent数组 private int[] sz; // sz[i]表示以i为根的集合中元素个数 public UnionFind3(int size) &#123; parent = new int[size]; sz = new int[size]; for (int i = 0 ; i &lt; size ; i++) &#123; parent[i] = i; sz[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; // 查看元素p和q是否同属一个集合 @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; // 合并元素p和q的集合，O(h) @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; // 根据两个元素所在树的元素个数不同判断合并的方向 // 将元素少的集合合并到元素多的集合 if (sz[pRoot] &lt; sz[qRoot]) &#123; parent[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; &#125; else &#123; parent[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; &#125; &#125; // 查找元素p所对应的集合编号，O(h) private int find(int p) &#123; if (p &lt; 0 || p &gt;= id.length) throw new IllegalArgumentException(&quot;out of bound&quot;); while (p != parent[p]) &#123; p = parent[p]; &#125; return p; &#125;&#125; Union Find IV - 基于rank的优化&emsp;&emsp;在UnionFindIII中，合并元素时虽然已经大大改善了链表情况，但是仍存在节点数量少的集合树却有着较高的深度&emsp;&emsp;因此需要引入基于rank(树的深度/高度)的优化，合并时将深度低的指向深度高的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class UnionFind4 implements UF &#123; private int[] parent; // parent数组 private int[] rank; // rank[i]表示以i为根的集合树的深度 public UnionFind4(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0 ; i &lt; size ; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; // 查看元素p和q是否同属一个集合 @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; // 合并元素p和q的集合，O(h) @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; // 根据两个元素所在树的深度不同判断合并的方向 // 将深度小的集合合并到深度大的集合 if (rank[pRoot] &lt; rank[qRoot]) &#123; parent[pRoot] = qRoot; &#125; else if (rank[qRoot] &lt; rank[pRoot]) &#123; parent[qRoot] = pRoot; &#125; else &#123; parent[pRoot] = qRoot; rank[qRoot]++; &#125; &#125; // 查找元素p所对应的集合编号，O(h) private int find(int p) &#123; if (p &lt; 0 || p &gt;= id.length) throw new IllegalArgumentException(&quot;out of bound&quot;); while (p != parent[p]) &#123; p = parent[p]; &#125; return p; &#125;&#125; Union Find V - 简易路径压缩(非递归)&emsp;&emsp;在树结构的并查集中，为了效率，我们希望树的深度越小越好&emsp;&emsp;因此可以采用路径压缩，在find过程中进行路径压缩&emsp;&emsp;时间复杂度: 严格意义上，O(log * n) -&gt; iterated logarithm &lt;&lt; O(logn)，近乎O(1)级别1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UnionFind5 implements UF &#123; private int[] parent; // parent数组 private int[] rank; // rank[i]表示以i为根的集合树的深度 public UnionFind5(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0 ; i &lt; size ; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; // 查看元素p和q是否同属一个集合 @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; // 合并元素p和q的集合，O(h) @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; // 根据两个元素所在树的深度不同判断合并的方向 // 将深度小的集合合并到深度大的集合 if (rank[pRoot] &lt; rank[qRoot]) &#123; parent[pRoot] = qRoot; &#125; else if (rank[qRoot] &lt; rank[pRoot]) &#123; parent[qRoot] = pRoot; &#125; else &#123; parent[pRoot] = qRoot; rank[qRoot]++; &#125; &#125; // 查找元素p所对应的集合编号，O(h) private int find(int p) &#123; if (p &lt; 0 || p &gt;= id.length) throw new IllegalArgumentException(&quot;out of bound&quot;); while (p != parent[p]) &#123; parent[p] = parent[parent[p]]; // 简易路径压缩，将该节点的父节点改为其“爷爷”节点 // 因此每次find，都会减少树的深度 // 这里，没有必要去维护rank数组，在IV中我们定义rank // 为树的深度，而此时rank可以代表相对排名 p = parent[p]; &#125; return p; &#125;&#125; Union Find VI - 递归路径压缩(find)&emsp;&emsp;在UnionFindV中，采用了简易路径压缩，每一次find都有很大可能导致新的路径压缩&emsp;&emsp;因此可以采用递归路径压缩，尽可能减少find时路径压缩的次数，但不代表性能的提升1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class UnionFind6 implements UF &#123; private int[] parent; // parent数组 private int[] rank; // rank[i]表示以i为根的集合树的深度 public UnionFind6(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0 ; i &lt; size ; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; // 查看元素p和q是否同属一个集合 @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; // 合并元素p和q的集合，O(h) @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; // 根据两个元素所在树的深度不同判断合并的方向 // 将深度小的集合合并到深度大的集合 if (rank[pRoot] &lt; rank[qRoot]) &#123; parent[pRoot] = qRoot; &#125; else if (rank[qRoot] &lt; rank[pRoot]) &#123; parent[qRoot] = pRoot; &#125; else &#123; parent[pRoot] = qRoot; rank[qRoot]++; &#125; &#125; // 查找元素p所对应的集合编号，O(h) private int find(int p) &#123; if (p &lt; 0 || p &gt;= id.length) throw new IllegalArgumentException(&quot;out of bound&quot;); // 递归路径压缩 if (p != parent[p]) &#123; parent[p] = find(parent[p]); &#125; return parent[p]; &#125;&#125;]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes基础]]></title>
    <url>%2FDeveloper-Tools%2Fkubernetes-basic%2F</url>
    <content type="text"><![CDATA[Kubernetes (k8s)简介面向云原生应用 - 以Google Borg(Google内部容器管理平台)为原型重新设计和实现的容器管理和编排调用工具。 云原生模式随着容器技术的出现以及应用面临的外部环境变化，云原生成为一种应用云化开发、部署和运行的主流方式。容器 - 应用部署、运行和管理的基本单元基础 - 应用的容器化和微服务化核心 - 借助容器管理自动化平台进行动态编排和资源优化利用 功能容器编排管理平台、微服务支撑平台、可移植的“云平台” Kubernetes基本概念Pods一个pod是k8s中应用的最小单元，pod可以由多个容器组成，有如下特性:1.单一IP地址2.共享localhost3.共享网络端口4.共享卷(volumes)5.共享IPC(inter-process communication)空间在pod中的容器是通过localhost进行通信，而pod之间的通信是由services来实现的。 ReplicaSets由于pods具有非永恒性(如果终止，便代表结束)，那么我们如何处理同个pod的多个版本运行？引入了replication controller，该控制器位于pod资源类型的上层来对其进行控制，可以有效防止失败/错误的发生；由此有了replica set，代表指定数量的需要运行的pods的集合。 Services在k8s中，一个服务(service)是pods之间通信的基础，就像pods之间的网络抽象。注：服务允许k8s为pods设置单一的DNS记录。 Deployments部署资源类型(deployment resource type)位于replica set的上层操作。一般来说，升级需要替换整个replica set，这样会导致应用停机进行升级；因此，k8s采用滚动升级(rolling upgrade), 使得我们可以不用停机就可以进行升级。 总结Deployments控制replica sets，然后replica sets控制pods。注意：使用部署资源类型时仍然需要用服务访问。 k8s相关工具Install and Set Up kubectlKubernetes命令行工具，允许用户使用指令来管理k8s集群。 Install MinikubeMinikube是为了开发者能在个人电脑上运行k8s而提供的一套工具，Go语言编写，通过调用虚拟化管理程序，创建出一个运行在虚拟机内的单节点集群。 VM driver documentation1minikube start --driver=&lt;driver_name&gt; 👆Enter the name of the hypervisor you installed in lowercase letters where &lt;driver_name&gt; is mentioned below.Driver is Docker 推荐文章 kubernetes1.13.1+etcd3.3.10+flanneld0.10集群部署]]></content>
      <categories>
        <category>Developer Tools</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单介绍 - Docker和ElasticSearch]]></title>
    <url>%2FDeveloper-Tools%2Fdocker-and-elastic%2F</url>
    <content type="text"><![CDATA[Docker简介容器引擎，能够打包/发布应用程序，包括系统环境、配置、依赖；虚拟化，沙箱机制(“轻量级虚拟机”)；Go语言编写。 安装下载安装包并安装 术语host: 宿主机(正在使用Docker的机器)image: 镜像(可以从远端拉取或者本地构建的可重复使用的软件打包)container: 镜像运行时的容器registry: 镜像的注册仓库daemon: Docker的守护进程，用来接受用户命令、和registry共享client: 客户端(给daemon输送命令) Run it (Terminal Command)1docker version 👆我们可以看到Client和Server的信息1docker run hello-world 👆hello from docker，我们可以看到docker运行流程1docker run -it alpine sh 👆docker run是运行，-it是输入输出重定向，alpine是最小Linux镜像，sh是shell命令(ubuntu -&gt; bash)1docker images 👆查看已经获取的本地镜像12docker psdocker ps -a 👆列出当前正在运行的容器12docker image rm &lt;image id&gt; [&lt;image id&gt; ...]docker rmi &lt;image id&gt; 👆移除获取的本地镜像(需要先移除对应的容器)1docker rm &lt;container id&gt; [&lt;container id&gt; ...] 👆移除获取的容器1docker run -d -p 8080:80 nginx 👆-d代表程序直接返回(后端持续运行，作为指挥进程)，由于nginx是一个网络服务器，-p 8080:80是将nginx的端口(80)映射到我们的本地端口(8080)1docker stop &lt;container id&gt; 👆终止已经启动的容器(id) Modify and Commit1docker cp &lt;file&gt; &lt;container id&gt;://path 👆向容器中拷贝文件file(暂时性：如果不commit，这种修改只存在于容器运行阶段)1docker commit -m &lt;msg&gt; &lt;container id&gt; [name] 👆保存改动为新的image，命令会返回该image id，省略name参数则name为 Create Image (Dockerfile)首先在想要打包的项目根目录下创建一个Dockerfile，然后用1docker build -t &lt;tag&gt; . 👆创建image，-t代表tag，’.’代表当前路径下的所有文件 Dockerfile语法小结FROM: base imageRUN: 执行命令ADD: 添加文件（比COPY更强大些，包括远程文件）COPY: 拷贝文件CMD: 执行命令EXPOSE: 暴露端口WORKDIR: 指定路径MAINTAINER: 维护者ENV: 设定环境变量ENTRYPOINT: 容器入口USER: 指定用户VOLUME: mount point(提供独立于容器之外的持久化存储) 举例👇示例1123FROM alpine:latestMAINTAINER rlCMD echo &quot;Hello, Docker~&quot; 👇示例21234567FROM ubuntuMAINTAINER rlRUN apt-get updateRUN apt-get install -y nginxCOPY index.html /var/www/htmlENTRYPOINT [&quot;/user/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]EXPOSE 80 Volume(挂载)方法一1docker run -d --name nginx -v /usr/share/nginx/html nginx 👆挂载，/usr/share/nginx/html代表容器内部的地址(nginx用来访问网页)1docker inspect nginx 👆检查信息，可以在返回结果中查找到”Mounts”下的”Source”，即是在宿主机上的挂载点123screen ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty/* If using Mac OS High Sierra */screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty 👆该指令只针对MAC(Linux无需该步骤)1cd /var/lib/docker/volumes/7c1601548c5adbd50e5bee2692939fb11bb5a52db52bb2ad1174c972b9550ec8/_data 👆Go to volume path(示例) 方法二1docker run -d -p 80:80 -v $PWD/html:/usr/share/nginx/html nginx 👆$PWD是环境变量，指向Host当前目录 方式三1docker create -v $PWD/data:/var/mydata --name data_container ubuntu 👆创建数据目录挂载与本地的挂载1docker run -it --volumes-from data_container ubuntu /bin/bash 👆进入到Docker容器内部去对数据进行修改，同时可以看到本地也会进行相应修改 Registry(镜像仓库) - 共享资源官方仓库(Docker Hub)，国内的一些仓库(daocloud，时速云，aliyun)1234docker search &lt;image&gt;docker pull &lt;image&gt;docker push &lt;image&gt;docker tag &lt;old_image&gt; &lt;new_image&gt; 👆搜索、拉取、发布、改变image的名字 docker-compose(多容器app)Linux环境下安装docker-compose(Mac/Windows无需此步骤)详情请见12sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-composesudo chmod a+x /usr/local/bin/docker-compose Commands1234docker-compose builddocker-compose up -ddocker-compose stopdocker-compose rm 👆多容器app的image创建、daemon启动服务、停止、删除服务中的各个容器 docker-compose.yml常用命令build 本地创建镜像command 覆盖缺省命令depends_on 连接容器ports 暴露端口volumes 卷image 拉取镜像 ElasticSearch简介全文搜索引擎，能够快速储存、搜索和分析海量数据，通常可以满足大量站内搜索的需求，例如维基百科、Github、Stack Overflow。不需要建表、配置字段等；数据可以JSON格式存储；原生支持搜索，不需要拼装查询语句。 安装方法一: 从网站下载安装包、配置、运行方法二: 直接使用Docker拉取对应版本的elasticsearch12docker pull docker.elastic.co/elasticsearch/elasticsearch:7.6.2docker run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.6.2 👆启动单点模式的elasticearch(可用于简单搜索)，端口9200 URL&lt;server&gt;:9200/index/type/idindex -&gt; databasetype -&gt; tableid -&gt; JSON obj其中，index和type无需预先创建；type中的数据类型可以不一致。在elasticsearch7中，为了解决不同type的字段重名问题，type概念被移除了。 GET, PUT, POST, DELETE (REST)GET -&gt; &lt;server&gt;:9200/index/type/_search 表示搜索在当前index的type下的全部对象GET -&gt; &lt;server&gt;:9200/index/type/_search?q=xxxxx 表示搜索在当前index的type下含有完整xxxxx的对象GET -&gt; &lt;server&gt;:9200/index/type/_mapping 配置类型PUT/POST -&gt; &lt;server&gt;:9200/index/type/id 创建/修改数据(不加id只能用POST来进行上传，id会随机分配) Coding (Go语言)Package Managers (import “github.com/olivere/elastic/v7”)👇(适合新手学习，非官方，抽象更简单)1go get github.com/olivere/elastic/v7 常用方法示例1234// Creates a new elasticsearch clientclient, err := elastic.NewClient( // Must turn off sniff in docker elastic.SetSniff(false)) 1234567// Stores the data (create/modify)resp, err := client.Index(). Index(&quot;example&quot;). Type(&quot;exp&quot;). Id(&quot;1&quot;). BodyJson(item). Do(context.Background()) 123456// Gets the dataresp, err := client.Get(). Index(&quot;example&quot;). Type(&quot;exp&quot;). Id(&quot;1&quot;). Do(context.Background()) 版权所有&emsp;&emsp;仅供交流学习，禁止转载商用！]]></content>
      <categories>
        <category>Developer Tools</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树/区间树(Segment Tree)]]></title>
    <url>%2FData-Structure%2FSegmentTree%2F</url>
    <content type="text"><![CDATA[线段树的定义&emsp;&emsp;实质是二叉树(平衡但不完全)，但每一个节点都是一个区间(根据业务逻辑的定义)。例如求和，根结点就是所有的元素和，叶子结点就是一个元素的值。&emsp;&emsp;如果区间内有n个元素，使用数组表示线段树，在一般不考虑添加元素的前提下，使用4n的静态空间即可。 线段树的应用&emsp;&emsp;对于某一类问题，我们关心的是一段区间(线段) 经典问题之一：区间染色&emsp;&emsp;有一面长度为n的墙，每次选择一段墙进行染色。&emsp;&emsp;1. m次操作后，我们可以看见多少种颜色?&emsp;&emsp;2. m次操作后，我们在[i, j]区间内看见多少种颜色?&emsp;&emsp;染色操作 = 更新区间，查询操作 = 查询区间 经典问题之二：区间统计查询&emsp;&emsp;查询一个区间[i, j]的最大值，最小值，或者区间数字和 代码实现(Java)线段树实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class SegmentTree&lt;E&gt; &#123; private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger) &#123; this.merger = merger; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; tree = (E[])new Object[4 * arr.length]; buildSegmentTree(0, 0, data.length - 1); &#125; public int getSize() &#123; return data.length; &#125; // 返回index位置上的元素 public E get(int index) &#123; // 索引验证: if(index &lt; 0 || index &gt;= data.length) throw new IllegalArgumentException(&quot;Illegal Index&quot;); return data[index]; &#125; // 返回区间[queryL, queryR]的值 public E query(int queryL, int queryR) &#123; // 合法性验证: if (queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) throw new IllegalArgumentException(&quot;Illegal Index&quot;); return query(0, 0, data.length - 1, queryL, queryR); &#125; // 将index位置的值，更新为e public void set(int index, E e) &#123; // 合法性验证: if(index &lt; 0 || index &gt;= data.length) throw new IllegalArgumentException(&quot;Illegal Index&quot;); data[index] = e; set(0, 0, data.length - 1, index, e); &#125; // 在treeIndex的位置创建表示区间[l...r]的线段树 private void buildSegmentTree(int treeIndex, int l, int r)&#123; if (l == r) &#123; tree[treeIndex] = data[l]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); // 实际上mid = (l + r) / 2, 防止整型溢出 int mid = l + (r - l) / 2; buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; // 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 private E query(int treeIndex, int l, int r, int queryL, int queryR) &#123; if (l == queryL &amp;&amp; r == queryR) return tree[treeIndex]; int mid = l + (r - l) / 2; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if (queryL &gt;= mid + 1) return query(rightTreeIndex, mid + 1, r, queryL, queryR); else if (queryR &lt;= mid) return query(leftTreeIndex, l, mid, queryL, queryR); E leftResult = query(leftTreeIndex, l, mid, queryL, mid); E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); &#125; // 在以treeIndex为根的线段树中更新index的值为e private void set(int treeIndex, int l, int r, int index, E e) &#123; if(l == r)&#123; tree[treeIndex] = e; return; &#125; int mid = l + (r - l) / 2; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if (index &gt;= mid + 1) set(rightTreeIndex, mid + 1, r, index, e); else set(leftTreeIndex, l, mid, index, e); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index)&#123; return 2 * index + 1; &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index)&#123; return 2 * index + 2; &#125;&#125; 融合器(接口):123public interface Merger&lt;E&gt; &#123; E merge(E a, E b);&#125; Main函数举例:1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Integer[] nums = &#123;-2, 0, 3, -5, 2, -1&#125;; SegmentTree&lt;Integer&gt; segTree = new SegmentTree&lt;&gt;(nums, new Merger&lt;Integer&gt;() &#123; @Override public Integer merge(Integer a, Integer b) &#123; return a + b; &#125; &#125;); &#125;&#125; 版权所有&emsp;&emsp;本文所述的知识总结出自慕课网课程 ——《算法大神带你玩转数据结构 从入门到精通》, 授课老师: liuyubobobo&emsp;&emsp;仅供交流学习，禁止转载商用！]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2FProgramming-Laugauge%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[IntroductionDefinitionMarkdown is a lightweight markup language with plain text formatting syntax. Its design allows it to be converted to many output formats, but the original tool by the same name only supports HTML. Markdown is often used to format readme files, for writing messages in online discussion forums, and to create rich text using a plain text editor. More Info: Wikipedia or 百度百科 Properties Plaint text Converts to HTML Easy to read and learn Enables faster creating and editing of blog posts SyntaxHeadingsTo create a heading, add number signs (#) in front of a word or phrase. The number of number signs you use should correspond to the heading level. For example, to create a heading level three, use three number signs (e.g., ### My Header). 123456# Level 1## Level 2### Level 3#### Level 4##### Level 5###### Level 6 EmphasisYou can add emphasis by making text bold or italic. BoldTo bold text, add two asterisks before and after a word or phrase. To bold the middle of a word for emphasis, add two asterisks without spaces around the letters. 1**bold text** The rendered output looks like this: bold text ItalicTo italicize text, add one asterisk before and after a word or phrase. To italicize the middle of a word for emphasis, add one asterisk without spaces around the letters. 1*italic text* The rendered output looks like this: bold text Bold and ItalicTo emphasize text with bold and italics at the same time, add three asterisks before and after a word or phrase. 1***bold and italic text*** The rendered output looks like this: bold and italic text BlockquotesTo create a blockquote, add a &gt; in front of a paragraph. 123&gt; This is a quotation.&gt;&gt;&gt; THis is nested quotation. The rendered output looks like this: This is a quotation. THis is nested quotation. ListsYou can organize items into ordered and unordered lists. Unordered ListsTo create an unordered list, add dashes, asterisks, or plus signs in front of line items. Indent one or more items to create a nested list. 123456- list item1- list item2 * list * list * list- list item3 The rendered output looks like this: list item1 list item2 list list list list item3 Ordered ListsTo create an ordered list, add line items with numbers followed by periods. The numbers don’t have to be in numerical order, but the list should start with the number one. 1234561. list item12. list item2 1. list 2. list 3. list3. list item3 The rendered output looks like this: list item1 list item2 list list list list item3 Horizontal RulesTo create a horizontal rule, use three or more asterisks, dashes, or underscores on a line by themselves. 123456*******-------_______ LinksTo create a link, enclose the link text in brackets and then follow it immediately with the URL in parentheses. 12[Google](https://www.google.com/)[Baidu](http://www.baidu.com/) The rendered output looks like this:GoogleBaidu CodeIf the word or phrase you want to denote as code includes one or more tick marks, you can escape it by enclosing the word or phrase in double tick marks. ImagesTo add an image, add an exclamation mark (!), followed by alt text in brackets, and the path or URL to the image asset in parentheses. You can optionally add a title after the URL in the parentheses. 1![Pikachu Detective](https://www.pokemoncenter.com/wcsstore/MarketingContent/detective-pikachu/landing_detective-pikachu_header.jpg &quot;Pikachu Detective&quot;) The rendered output looks like this: FormThe second line separates the header and the content.By default, text is left; Add two colons before and after dashes, text is center; Add one colon after dashes, text is right. 12345Name|Number|E-mail--|:--:|--:Lucas|1|xxxxx@xxxxTracy|2|xxxxx@xxxxMento|3|xxxxx@xxxx The rendered output looks like this: Name Number E-mail Lucas 1 xxxxx@xxxx Tracy 2 xxxxx@xxxx Mento 3 xxxxx@xxxx Recommended Articles Basic Syntax from Markdown Guide Markdown基本语法 来自高鸿祥的简书]]></content>
      <categories>
        <category>Programming Laugauge</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
